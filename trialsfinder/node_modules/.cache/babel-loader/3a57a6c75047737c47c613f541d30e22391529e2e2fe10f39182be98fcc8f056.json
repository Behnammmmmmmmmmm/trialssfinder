{"ast":null,"code":"class APICache{constructor(){let options=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};this.cache=new Map();this.pendingRequests=new Map();this.maxSize=options.max||500;this.defaultTTL=options.ttl||1000*60*5;// 5 minutes default\n}generateKey(url,params){const sortedParams=params?JSON.stringify(params,Object.keys(params).sort()):'';return`${url}:${sortedParams}`;}isExpired(item){return Date.now()>item.expiry;}evictOldest(){if(this.cache.size>=this.maxSize){const firstKey=this.cache.keys().next().value;if(firstKey){this.cache.delete(firstKey);}}}get(key){const item=this.cache.get(key);if(!item){return undefined;}if(this.isExpired(item)){this.cache.delete(key);return undefined;}return item.data;}set(key,data,ttl){this.evictOldest();const expiry=Date.now()+(ttl||this.defaultTTL);this.cache.set(key,{data,expiry});}async getOrFetch(url,fetcher){let options=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};const key=this.generateKey(url,options.params);// Check cache first\nconst cached=this.get(key);if(cached!==undefined){return cached;}// Check if request is already pending\nconst pending=this.pendingRequests.get(key);if(pending){return pending;}// Make request and cache result\nconst request=fetcher().then(data=>{this.set(key,data,options.ttl);this.pendingRequests.delete(key);return data;}).catch(error=>{this.pendingRequests.delete(key);throw error;});this.pendingRequests.set(key,request);return request;}invalidate(pattern){if(!pattern){this.cache.clear();return;}// Invalidate keys matching pattern\nfor(const key of Array.from(this.cache.keys())){if(key.includes(pattern)){this.cache.delete(key);}}}invalidateUser(userId){this.invalidate(`user:${userId}`);}invalidateTrial(trialId){this.invalidate(`trial:${trialId}`);this.invalidate('trials:');}}export const apiCache=new APICache();// Axios interceptor for automatic caching\nexport const setupCacheInterceptor=axiosInstance=>{// Check if axiosInstance exists and has interceptors\nif(!axiosInstance||!axiosInstance.interceptors){console.warn('Invalid axios instance provided to setupCacheInterceptor');return;}axiosInstance.interceptors.request.use(config=>{// Only cache GET requests\nif(config.method==='get'&&config.cache!==false){const cacheKey=apiCache.generateKey(config.url,config.params);const cached=apiCache.get(cacheKey);if(cached){config.adapter=()=>Promise.resolve({data:cached,status:200,statusText:'OK',headers:{'x-cache':'HIT'},config});}}return config;});axiosInstance.interceptors.response.use(response=>{// Cache successful GET responses\nif(response.config.method==='get'&&response.status===200&&response.config.cache!==false){const cacheKey=apiCache.generateKey(response.config.url,response.config.params);apiCache.set(cacheKey,response.data,response.config.cacheTTL);}return response;});};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}