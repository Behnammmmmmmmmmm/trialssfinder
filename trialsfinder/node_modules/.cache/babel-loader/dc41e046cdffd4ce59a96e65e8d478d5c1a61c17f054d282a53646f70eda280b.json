{"ast":null,"code":"import axios from 'axios';\nimport { apiCache, setupCacheInterceptor } from './apiCache';\n\n// Use proxy for development, direct path for production\nconst API_BASE_URL = process.env.NODE_ENV === 'development' ? '/api' // This will use the proxy defined in webpack.config.js\n: '/api';\nconst api = axios.create({\n  baseURL: API_BASE_URL,\n  headers: {\n    common: {\n      'Content-Type': 'application/json'\n    }\n  },\n  withCredentials: true,\n  // Important for CSRF\n  timeout: 30000 // 30 second timeout\n});\n\n// Get CSRF token from cookie\nfunction getCookie(name) {\n  let cookieValue = null;\n  if (document.cookie && document.cookie !== '') {\n    const cookies = document.cookie.split(';');\n    for (let i = 0; i < cookies.length; i++) {\n      const cookie = cookies[i].trim();\n      if (cookie.substring(0, name.length + 1) === name + '=') {\n        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));\n        break;\n      }\n    }\n  }\n  return cookieValue;\n}\n\n// Setup cache interceptor\nsetupCacheInterceptor(api);\n\n// Request interceptor\napi.interceptors.request.use(config => {\n  // Add auth token\n  const token = localStorage.getItem('access_token');\n  if (token) {\n    config.headers.Authorization = `Bearer ${token}`;\n  }\n\n  // Add CSRF token for non-GET requests\n  if (config.method !== 'get') {\n    const csrfToken = getCookie('csrftoken');\n    if (csrfToken) {\n      config.headers['X-CSRFToken'] = csrfToken;\n    }\n  }\n\n  // Add security headers\n  config.headers['X-Requested-With'] = 'XMLHttpRequest';\n  return config;\n}, error => {\n  return Promise.reject(error);\n});\n\n// Response interceptor\napi.interceptors.response.use(response => response, async error => {\n  const originalRequest = error.config;\n\n  // Handle network errors\n  if (!error.response) {\n    // Backend is not available\n    if (process.env.NODE_ENV === 'development') {\n      console.warn('Backend server is not running. Returning mock data.');\n\n      // Return mock data based on the endpoint\n      if (originalRequest.url?.includes('/trials')) {\n        return {\n          data: {\n            results: [],\n            count: 0,\n            next: null,\n            previous: null\n          }\n        };\n      }\n      if (originalRequest.url?.includes('/auth/me')) {\n        return Promise.reject(new Error('Not authenticated'));\n      }\n      return Promise.reject(error);\n    }\n    return Promise.reject(error);\n  }\n\n  // Handle 401 errors\n  if (error.response?.status === 401 && !originalRequest._retry) {\n    originalRequest._retry = true;\n    try {\n      const refreshToken = localStorage.getItem('refresh_token');\n      if (!refreshToken) {\n        throw new Error('No refresh token');\n      }\n      const response = await axios.post(`${API_BASE_URL}/auth/refresh/`, {\n        refresh: refreshToken\n      });\n      localStorage.setItem('access_token', response.data.access);\n      api.defaults.headers.common['Authorization'] = `Bearer ${response.data.access}`;\n      return api(originalRequest);\n    } catch (refreshError) {\n      // Clear cache on logout\n      apiCache.invalidate('');\n      localStorage.clear();\n\n      // Only redirect in production\n      if (process.env.NODE_ENV === 'production') {\n        window.location.href = '/login';\n      }\n      return Promise.reject(error);\n    }\n  }\n  return Promise.reject(error);\n});\n\n// Cache invalidation helpers\nexport const invalidateUserCache = userId => {\n  apiCache.invalidateUser(userId);\n};\nexport const invalidateTrialCache = trialId => {\n  apiCache.invalidateTrial(trialId);\n};\nexport default api;","map":{"version":3,"names":["axios","apiCache","setupCacheInterceptor","API_BASE_URL","process","env","NODE_ENV","api","create","baseURL","headers","common","withCredentials","timeout","getCookie","name","cookieValue","document","cookie","cookies","split","i","length","trim","substring","decodeURIComponent","interceptors","request","use","config","token","localStorage","getItem","Authorization","method","csrfToken","error","Promise","reject","response","originalRequest","console","warn","url","includes","data","results","count","next","previous","Error","status","_retry","refreshToken","post","refresh","setItem","access","defaults","refreshError","invalidate","clear","window","location","href","invalidateUserCache","userId","invalidateUser","invalidateTrialCache","trialId","invalidateTrial"],"sources":["C:/Users/behna/Desktop/trialssfinder/trialsfinder/src/utils/api.ts"],"sourcesContent":["import axios from 'axios';\r\nimport { apiCache, setupCacheInterceptor } from './apiCache';\r\n\r\n// Use proxy for development, direct path for production\r\nconst API_BASE_URL = process.env.NODE_ENV === 'development' \r\n  ? '/api'  // This will use the proxy defined in webpack.config.js\r\n  : '/api';\r\n\r\nconst api = axios.create({\r\n  baseURL: API_BASE_URL,\r\n  headers: {\r\n    common: {\r\n      'Content-Type': 'application/json'\r\n    }\r\n  },\r\n  withCredentials: true, // Important for CSRF\r\n  timeout: 30000 // 30 second timeout\r\n});\r\n\r\n// Get CSRF token from cookie\r\nfunction getCookie(name: string): string | null {\r\n  let cookieValue = null;\r\n  if (document.cookie && document.cookie !== '') {\r\n    const cookies = document.cookie.split(';');\r\n    for (let i = 0; i < cookies.length; i++) {\r\n      const cookie = cookies[i].trim();\r\n      if (cookie.substring(0, name.length + 1) === (name + '=')) {\r\n        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));\r\n        break;\r\n      }\r\n    }\r\n  }\r\n  return cookieValue;\r\n}\r\n\r\n// Setup cache interceptor\r\nsetupCacheInterceptor(api);\r\n\r\n// Request interceptor\r\napi.interceptors.request.use(\r\n  (config) => {\r\n    // Add auth token\r\n    const token = localStorage.getItem('access_token');\r\n    if (token) {\r\n      config.headers.Authorization = `Bearer ${token}`;\r\n    }\r\n    \r\n    // Add CSRF token for non-GET requests\r\n    if (config.method !== 'get') {\r\n      const csrfToken = getCookie('csrftoken');\r\n      if (csrfToken) {\r\n        config.headers['X-CSRFToken'] = csrfToken;\r\n      }\r\n    }\r\n    \r\n    // Add security headers\r\n    config.headers['X-Requested-With'] = 'XMLHttpRequest';\r\n    \r\n    return config;\r\n  },\r\n  (error) => {\r\n    return Promise.reject(error);\r\n  }\r\n);\r\n\r\n// Response interceptor\r\napi.interceptors.response.use(\r\n  (response) => response,\r\n  async (error) => {\r\n    const originalRequest = error.config;\r\n    \r\n    // Handle network errors\r\n    if (!error.response) {\r\n      // Backend is not available\r\n      if (process.env.NODE_ENV === 'development') {\r\n        console.warn('Backend server is not running. Returning mock data.');\r\n        \r\n        // Return mock data based on the endpoint\r\n        if (originalRequest.url?.includes('/trials')) {\r\n          return {\r\n            data: {\r\n              results: [],\r\n              count: 0,\r\n              next: null,\r\n              previous: null\r\n            }\r\n          };\r\n        }\r\n        \r\n        if (originalRequest.url?.includes('/auth/me')) {\r\n          return Promise.reject(new Error('Not authenticated'));\r\n        }\r\n        \r\n        return Promise.reject(error);\r\n      }\r\n      \r\n      return Promise.reject(error);\r\n    }\r\n    \r\n    // Handle 401 errors\r\n    if (error.response?.status === 401 && !originalRequest._retry) {\r\n      originalRequest._retry = true;\r\n      \r\n      try {\r\n        const refreshToken = localStorage.getItem('refresh_token');\r\n        if (!refreshToken) {\r\n          throw new Error('No refresh token');\r\n        }\r\n        \r\n        const response = await axios.post(`${API_BASE_URL}/auth/refresh/`, { \r\n          refresh: refreshToken \r\n        });\r\n        \r\n        localStorage.setItem('access_token', response.data.access);\r\n        api.defaults.headers.common['Authorization'] = `Bearer ${response.data.access}`;\r\n        \r\n        return api(originalRequest);\r\n      } catch (refreshError) {\r\n        // Clear cache on logout\r\n        apiCache.invalidate('');\r\n        localStorage.clear();\r\n        \r\n        // Only redirect in production\r\n        if (process.env.NODE_ENV === 'production') {\r\n          window.location.href = '/login';\r\n        }\r\n        \r\n        return Promise.reject(error);\r\n      }\r\n    }\r\n    \r\n    return Promise.reject(error);\r\n  }\r\n);\r\n\r\n// Cache invalidation helpers\r\nexport const invalidateUserCache = (userId: number) => {\r\n  apiCache.invalidateUser(userId);\r\n};\r\n\r\nexport const invalidateTrialCache = (trialId: number) => {\r\n  apiCache.invalidateTrial(trialId);\r\n};\r\n\r\nexport default api;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}