{"ast":null,"code":"class APICache {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.cache = new Map();\n    this.pendingRequests = new Map();\n    this.maxSize = options.max || 500;\n    this.defaultTTL = options.ttl || 1000 * 60 * 5; // 5 minutes default\n  }\n  generateKey(url, params) {\n    const sortedParams = params ? JSON.stringify(params, Object.keys(params).sort()) : '';\n    return `${url}:${sortedParams}`;\n  }\n  isExpired(item) {\n    return Date.now() > item.expiry;\n  }\n  evictOldest() {\n    if (this.cache.size >= this.maxSize) {\n      const firstKey = this.cache.keys().next().value;\n      if (firstKey) {\n        this.cache.delete(firstKey);\n      }\n    }\n  }\n  get(key) {\n    const item = this.cache.get(key);\n    if (!item) {\n      return undefined;\n    }\n    if (this.isExpired(item)) {\n      this.cache.delete(key);\n      return undefined;\n    }\n    return item.data;\n  }\n  set(key, data, ttl) {\n    this.evictOldest();\n    const expiry = Date.now() + (ttl || this.defaultTTL);\n    this.cache.set(key, {\n      data,\n      expiry\n    });\n  }\n  async getOrFetch(url, fetcher) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const key = this.generateKey(url, options.params);\n\n    // Check cache first\n    const cached = this.get(key);\n    if (cached !== undefined) {\n      return cached;\n    }\n\n    // Check if request is already pending\n    const pending = this.pendingRequests.get(key);\n    if (pending) {\n      return pending;\n    }\n\n    // Make request and cache result\n    const request = fetcher().then(data => {\n      this.set(key, data, options.ttl);\n      this.pendingRequests.delete(key);\n      return data;\n    }).catch(error => {\n      this.pendingRequests.delete(key);\n      throw error;\n    });\n    this.pendingRequests.set(key, request);\n    return request;\n  }\n  invalidate(pattern) {\n    if (!pattern) {\n      this.cache.clear();\n      return;\n    }\n\n    // Invalidate keys matching pattern\n    for (const key of Array.from(this.cache.keys())) {\n      if (key.includes(pattern)) {\n        this.cache.delete(key);\n      }\n    }\n  }\n  invalidateUser(userId) {\n    this.invalidate(`user:${userId}`);\n  }\n  invalidateTrial(trialId) {\n    this.invalidate(`trial:${trialId}`);\n    this.invalidate('trials:');\n  }\n}\nexport const apiCache = new APICache();\n\n// Axios interceptor for automatic caching\nexport const setupCacheInterceptor = axiosInstance => {\n  // Check if axiosInstance exists and has interceptors\n  if (!axiosInstance || !axiosInstance.interceptors) {\n    console.warn('Invalid axios instance provided to setupCacheInterceptor');\n    return;\n  }\n  axiosInstance.interceptors.request.use(config => {\n    // Only cache GET requests\n    if (config.method === 'get' && config.cache !== false) {\n      const cacheKey = apiCache.generateKey(config.url, config.params);\n      const cached = apiCache.get(cacheKey);\n      if (cached) {\n        config.adapter = () => Promise.resolve({\n          data: cached,\n          status: 200,\n          statusText: 'OK',\n          headers: {\n            'x-cache': 'HIT'\n          },\n          config\n        });\n      }\n    }\n    return config;\n  });\n  axiosInstance.interceptors.response.use(response => {\n    // Cache successful GET responses\n    if (response.config.method === 'get' && response.status === 200 && response.config.cache !== false) {\n      const cacheKey = apiCache.generateKey(response.config.url, response.config.params);\n      apiCache.set(cacheKey, response.data, response.config.cacheTTL);\n    }\n    return response;\n  });\n};","map":{"version":3,"names":["APICache","constructor","options","arguments","length","undefined","cache","Map","pendingRequests","maxSize","max","defaultTTL","ttl","generateKey","url","params","sortedParams","JSON","stringify","Object","keys","sort","isExpired","item","Date","now","expiry","evictOldest","size","firstKey","next","value","delete","get","key","data","set","getOrFetch","fetcher","cached","pending","request","then","catch","error","invalidate","pattern","clear","Array","from","includes","invalidateUser","userId","invalidateTrial","trialId","apiCache","setupCacheInterceptor","axiosInstance","interceptors","console","warn","use","config","method","cacheKey","adapter","Promise","resolve","status","statusText","headers","response","cacheTTL"],"sources":["C:/Users/behna/Desktop/trialssfinder/trialsfinder/src/utils/apiCache.ts"],"sourcesContent":["interface CacheOptions {\r\n  ttl?: number;\r\n  max?: number;\r\n}\r\n\r\ninterface CacheItem<T> {\r\n  data: T;\r\n  expiry: number;\r\n}\r\n\r\nclass APICache {\r\n  private cache: Map<string, CacheItem<any>>;\r\n  private pendingRequests: Map<string, Promise<any>>;\r\n  private maxSize: number;\r\n  private defaultTTL: number;\r\n\r\n  constructor(options: CacheOptions = {}) {\r\n    this.cache = new Map();\r\n    this.pendingRequests = new Map();\r\n    this.maxSize = options.max || 500;\r\n    this.defaultTTL = options.ttl || 1000 * 60 * 5; // 5 minutes default\r\n  }\r\n\r\n  generateKey(url: string, params?: any): string {\r\n    const sortedParams = params ? JSON.stringify(params, Object.keys(params).sort()) : '';\r\n    return `${url}:${sortedParams}`;\r\n  }\r\n\r\n  private isExpired(item: CacheItem<any>): boolean {\r\n    return Date.now() > item.expiry;\r\n  }\r\n\r\n  private evictOldest(): void {\r\n    if (this.cache.size >= this.maxSize) {\r\n      const firstKey = this.cache.keys().next().value;\r\n      if (firstKey) {\r\n        this.cache.delete(firstKey);\r\n      }\r\n    }\r\n  }\r\n\r\n  get<T>(key: string): T | undefined {\r\n    const item = this.cache.get(key);\r\n    if (!item) {\r\n      return undefined;\r\n    }\r\n    \r\n    if (this.isExpired(item)) {\r\n      this.cache.delete(key);\r\n      return undefined;\r\n    }\r\n    \r\n    return item.data;\r\n  }\r\n\r\n  set<T>(key: string, data: T, ttl?: number): void {\r\n    this.evictOldest();\r\n    \r\n    const expiry = Date.now() + (ttl || this.defaultTTL);\r\n    this.cache.set(key, { data, expiry });\r\n  }\r\n\r\n  async getOrFetch<T>(\r\n    url: string,\r\n    fetcher: () => Promise<T>,\r\n    options: { ttl?: number; params?: any } = {}\r\n  ): Promise<T> {\r\n    const key = this.generateKey(url, options.params);\r\n    \r\n    // Check cache first\r\n    const cached = this.get<T>(key);\r\n    if (cached !== undefined) {\r\n      return cached;\r\n    }\r\n\r\n    // Check if request is already pending\r\n    const pending = this.pendingRequests.get(key);\r\n    if (pending) {\r\n      return pending;\r\n    }\r\n\r\n    // Make request and cache result\r\n    const request = fetcher()\r\n      .then(data => {\r\n        this.set(key, data, options.ttl);\r\n        this.pendingRequests.delete(key);\r\n        return data;\r\n      })\r\n      .catch(error => {\r\n        this.pendingRequests.delete(key);\r\n        throw error;\r\n      });\r\n\r\n    this.pendingRequests.set(key, request);\r\n    return request;\r\n  }\r\n\r\n  invalidate(pattern?: string): void {\r\n    if (!pattern) {\r\n      this.cache.clear();\r\n      return;\r\n    }\r\n\r\n    // Invalidate keys matching pattern\r\n    for (const key of Array.from(this.cache.keys())) {\r\n      if (key.includes(pattern)) {\r\n        this.cache.delete(key);\r\n      }\r\n    }\r\n  }\r\n\r\n  invalidateUser(userId: number): void {\r\n    this.invalidate(`user:${userId}`);\r\n  }\r\n\r\n  invalidateTrial(trialId: number): void {\r\n    this.invalidate(`trial:${trialId}`);\r\n    this.invalidate('trials:');\r\n  }\r\n}\r\n\r\nexport const apiCache = new APICache();\r\n\r\n// Axios interceptor for automatic caching\r\nexport const setupCacheInterceptor = (axiosInstance: any) => {\r\n  // Check if axiosInstance exists and has interceptors\r\n  if (!axiosInstance || !axiosInstance.interceptors) {\r\n    console.warn('Invalid axios instance provided to setupCacheInterceptor');\r\n    return;\r\n  }\r\n\r\n  axiosInstance.interceptors.request.use((config: any) => {\r\n    // Only cache GET requests\r\n    if (config.method === 'get' && config.cache !== false) {\r\n      const cacheKey = apiCache.generateKey(config.url, config.params);\r\n      const cached = apiCache.get(cacheKey);\r\n      \r\n      if (cached) {\r\n        config.adapter = () => Promise.resolve({\r\n          data: cached,\r\n          status: 200,\r\n          statusText: 'OK',\r\n          headers: { 'x-cache': 'HIT' },\r\n          config,\r\n        });\r\n      }\r\n    }\r\n    return config;\r\n  });\r\n\r\n  axiosInstance.interceptors.response.use((response: any) => {\r\n    // Cache successful GET responses\r\n    if (\r\n      response.config.method === 'get' &&\r\n      response.status === 200 &&\r\n      response.config.cache !== false\r\n    ) {\r\n      const cacheKey = apiCache.generateKey(response.config.url, response.config.params);\r\n      apiCache.set(cacheKey, response.data, response.config.cacheTTL);\r\n    }\r\n    return response;\r\n  });\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}